<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Coding Interview - Session {{ session.id }}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 4px 1fr;
            grid-template-rows: 1fr 4px 1fr;
            height: 100vh;
            background-color: #1e1e1e;
        }

        .problem-section {
            grid-column: 1;
            grid-row: 1;
            background-color: #2d2d30;
            padding: 20px;
            overflow-y: auto;
            border: 1px solid #3e3e42;
        }

        .chat-section {
            grid-column: 1;
            grid-row: 3;
            background-color: #252526;
            display: flex;
            flex-direction: column;
            border: 1px solid #3e3e42;
            min-height: 0;
        }

        .ide-section {
            grid-column: 3;
            grid-row: 1 / 4;
            background-color: #1e1e1e;
            display: flex;
            flex-direction: column;
            border: 1px solid #3e3e42;
        }

        .resize-handle-horizontal {
            grid-column: 2;
            grid-row: 1 / 4;
            background-color: #3e3e42;
            cursor: col-resize;
            position: relative;
        }

        .resize-handle-horizontal:hover {
            background-color: #4fc3f7;
        }

        .resize-handle-vertical {
            grid-column: 1;
            grid-row: 2;
            background-color: #3e3e42;
            cursor: row-resize;
            position: relative;
        }

        .resize-handle-vertical:hover {
            background-color: #4fc3f7;
        }

        .resize-handle {
            background-color: #3e3e42;
            cursor: col-resize;
            width: 4px;
            position: relative;
        }

        .resize-handle:hover {
            background-color: #4fc3f7;
        }

        .resize-handle-vertical {
            background-color: #3e3e42;
            cursor: row-resize;
            height: 4px;
            position: relative;
        }

        .resize-handle-vertical:hover {
            background-color: #4fc3f7;
        }

        .problem-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #4fc3f7;
            line-height: 1.2;
        }

        .problem-difficulty {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .difficulty-easy { background-color: #4caf50; color: white; }
        .difficulty-medium { background-color: #ff9800; color: white; }
        .difficulty-hard { background-color: #f44336; color: white; }

        .problem-description {
            line-height: 1.6;
            margin-bottom: 20px;
            font-size: 16px;
            color: #ffffff;
        }

        .problem-constraints {
            background-color: #2d2d30;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #3e3e42;
        }

        .problem-constraints strong {
            color: #ffffff;
            font-size: 16px;
            display: block;
            margin-bottom: 8px;
        }

        .problem-constraints div {
            color: #cccccc;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }

        .problem-examples {
            margin-bottom: 20px;
        }

        .problem-examples strong {
            color: #ffffff;
            font-size: 16px;
            display: block;
            margin-bottom: 12px;
        }

        .example {
            margin-bottom: 16px;
            padding: 12px;
            background-color: #2d2d30;
            border-radius: 6px;
            border: 1px solid #3e3e42;
        }

        .example-label {
            font-weight: bold;
            color: #4fc3f7;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .example div {
            margin-bottom: 6px;
            font-size: 14px;
            line-height: 1.4;
        }

        .example strong {
            color: #ffffff;
            font-weight: 600;
        }

        .example code {
            background-color: #1e1e1e;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #4fc3f7;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            min-height: 0;
        }

        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
            max-width: 80%;
        }

        .message.user {
            background-color: #007acc;
            margin-left: auto;
        }

        .message.ai {
            background-color: #3e3e42;
        }

        .message.system {
            background-color: #4caf50;
            text-align: center;
            max-width: 100%;
        }

        .message-header {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        /* Markdown styling for chat messages */
        .message h1, .message h2, .message h3, .message h4, .message h5, .message h6 {
            color: #4fc3f7;
            margin: 10px 0 5px 0;
        }

        .message code {
            background-color: #2d2d30;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #4fc3f7;
        }

        .message pre {
            background-color: #2d2d30;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 10px 0;
        }

        .message pre code {
            background: none;
            padding: 0;
            color: #ffffff;
        }

        .message ul, .message ol {
            margin: 10px 0;
            padding-left: 20px;
        }

        .message li {
            margin: 5px 0;
        }

        .message blockquote {
            border-left: 4px solid #4fc3f7;
            padding-left: 15px;
            margin: 10px 0;
            color: #cccccc;
        }

        .message strong {
            color: #ffffff;
            font-weight: bold;
        }

        .message em {
            color: #cccccc;
            font-style: italic;
        }

        .chat-input {
            padding: 20px;
            background-color: #2d2d30;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .chat-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            background-color: #3e3e42;
            color: white;
            font-size: 14px;
        }

        .chat-input input:focus {
            outline: none;
            border-color: #007acc;
        }

        .chat-input button {
            padding: 10px 20px;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .chat-input button:hover {
            background-color: #005a9e;
        }

        .voice-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .voice-button {
            padding: 10px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .voice-button.mic {
            background-color: #4caf50;
            color: white;
        }

        .voice-button.mic:hover {
            background-color: #45a049;
        }

        .voice-button.mic.recording {
            background-color: #f44336;
            animation: pulse 1s infinite;
        }

        .voice-button.speaker {
            background-color: #2196f3;
            color: white;
        }

        .voice-button.speaker:hover {
            background-color: #1976d2;
        }

        .voice-button.speaker.speaking {
            background-color: #ff9800;
            animation: pulse 1s infinite;
        }
        
        .voice-button.respeak {
            background-color: #FF9800;
            color: white;
        }
        
        .voice-button.respeak:hover {
            background-color: #F57C00;
        }
        
        .voice-button.respeak:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .voice-button.mic.active {
            background-color: #4CAF50;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .voice-status {
            font-size: 12px;
            color: #cccccc;
            margin-left: 10px;
        }

        .character-counter {
            font-size: 10px;
            color: #888888;
            margin-left: 10px;
            padding: 2px 6px;
            background-color: #2d2d30;
            border-radius: 3px;
        }

        .character-counter.warning {
            color: #ff9800;
        }

        .character-counter.critical {
            color: #f44336;
        }

        .code-editor-container {
            flex: 1;
            display: grid;
            grid-template-rows: 1fr 4px 200px;
            min-height: 0;
        }

        .code-editor {
            grid-row: 1;
            background-color: #1e1e1e;
            border: none;
            color: #ffffff;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            padding: 20px;
            resize: none;
            outline: none;
        }

        .resize-handle-code {
            grid-row: 2;
            background-color: #3e3e42;
            cursor: row-resize;
            position: relative;
        }

        .resize-handle-code:hover {
            background-color: #4fc3f7;
        }

        .output-section {
            grid-row: 3;
            background-color: #2d2d30;
            padding: 20px;
            border-top: 1px solid #3e3e42;
            overflow-y: auto;
        }

        .ide-header {
            background-color: #2d2d30;
            padding: 10px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ide-title {
            font-weight: bold;
            color: #4fc3f7;
        }

        .ide-controls {
            display: flex;
            gap: 10px;
        }

        .ide-controls button {
            padding: 5px 10px;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .ide-controls button:hover {
            background-color: #005a9e;
        }

        .ide-controls button.end-interview {
            background-color: #dc3545;
        }

        .ide-controls button.end-interview:hover {
            background-color: #c82333;
        }
        
        .ide-controls button.recording-button {
            background-color: #28a745;
            color: white;
        }
        
        .ide-controls button.recording-button:hover {
            background-color: #218838;
        }
        
        .ide-controls button.recording-button.recording {
            background-color: #dc3545;
            animation: pulse 1.5s infinite;
        }
        
        .ide-controls button.recording-button.recording:hover {
            background-color: #c82333;
        }


        .output-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #4fc3f7;
        }

        .output-content {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }

        .status-bar {
            background-color: #007acc;
            padding: 5px 20px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .loading {
            opacity: 0.6;
        }

        .error {
            color: #f44336;
        }

        .success {
            color: #4caf50;
        }

    </style>
</head>
<body>
    <div class="container">
        <!-- Problem Section (Top Left) -->
        <div class="problem-section">
            {% if session.problem %}
                <div class="problem-title">{{ session.problem.title }}</div>
                <div class="problem-difficulty difficulty-{{ session.problem.difficulty }}">
                    {{ session.problem.difficulty|title }}
                </div>
                <div class="problem-description">{{ session.problem.description|linebreaks }}</div>
                
                {% if session.problem.constraints %}
                    <div class="problem-constraints">
                        <strong>Constraints:</strong><br>
                        {{ session.problem.constraints|linebreaks }}
                    </div>
                {% endif %}
                
                {% if session.problem.examples %}
                    <div class="problem-examples">
                        <strong>Examples:</strong><br>
                        {% for example in session.problem.examples %}
                            <div class="example">
                                <div class="example-label">Example {{ forloop.counter }}:</div>
                                <div><strong>Input:</strong> {{ example.input }}</div>
                                <div><strong>Output:</strong> {{ example.output }}</div>
                                {% if example.explanation %}
                                    <div><strong>Explanation:</strong> {{ example.explanation }}</div>
                                {% endif %}
                            </div>
                        {% endfor %}
                    </div>
                {% endif %}
            {% else %}
                <div class="problem-title">Waiting for Problem Selection</div>
                <div class="problem-description">
                    The AI interviewer is assessing your preferences and will select an appropriate problem for you.
                </div>
            {% endif %}
        </div>

        <!-- Vertical Resize Handle (Between Problem and Chat) -->
        <div class="resize-handle-vertical" id="verticalResizeHandle"></div>

        <!-- Chat Section (Bottom Left) -->
        <div class="chat-section">
            <div class="chat-messages" id="chatMessages">
                {% for message in messages %}
                    <div class="message {{ message.message_type }}">
                        <div class="message-header">{{ message.message_type|title }} - {{ message.timestamp|date:"H:i" }}</div>
                        <div>{{ message.content|linebreaks }}</div>
                    </div>
                {% endfor %}
            </div>
            
            <div class="chat-input">
                <input type="text" id="messageInput" placeholder="Type your message..." autocomplete="off">
                <div class="voice-controls">
                    <button class="voice-button mic" id="micButton" onclick="toggleVoiceInput()" title="Click to start/stop voice input">
                        🎤
                    </button>
                    <button class="voice-button speaker" id="speakerButton" onclick="toggleSpeaking()" title="Click to hear AI response">
                        🔊
                    </button>
                    <button class="voice-button respeak" id="respeakButton" onclick="respeakLastAI()" title="Re-speak Last AI Message (Saves API calls)">
                        🔁
                    </button>
                    <span class="voice-status" id="voiceStatus"></span>
                    <span class="character-counter" id="characterCounter">0 chars</span>
                </div>
                <button onclick="sendMessage()">Send</button>
            </div>
        </div>

        <!-- Horizontal Resize Handle (Between Left and Right Panels) -->
        <div class="resize-handle-horizontal" id="horizontalResizeHandle"></div>

        <!-- IDE Section (Right Side) -->
        <div class="ide-section">
            <div class="ide-header">
                <div class="ide-title">Code Editor</div>
                <div class="ide-controls">
                    <button onclick="runCode()">Run</button>
                    <button onclick="submitCode()">Submit</button>
                    <button onclick="requestHint()">Hint</button>
                    <button onclick="requestCodeHelp()">Get Help</button>
                    <button onclick="toggleRecording()" class="recording-button" id="recordingButton">🎥 Start Recording</button>
                    <button onclick="endInterview()" class="end-interview">End Interview</button>
                </div>
            </div>
            
           <div class="code-editor-container">
  <!-- MONACO EDITOR -->
  <div id="monacoEditor" style="grid-row: 1; height: 100%; width: 100%;"></div>

  <!-- Code Editor Resize Handle -->
  <div class="resize-handle-code" id="codeResizeHandle"></div>

  <div class="output-section">
    <div class="output-title">Output</div>
    <div class="output-content" id="outputContent">Ready to run your code...</div>
  </div>
</div>


<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
  let editor;

  require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' } });
  require(["vs/editor/editor.main"], function () {
    editor = monaco.editor.create(document.getElementById('monacoEditor'), {
      value: '# Write your Python code here',
      language: 'python',
      theme: 'vs-dark',
      automaticLayout: true
    });
    
    // Make editor globally accessible
    window.monacoEditor = editor;
    console.log('Monaco editor initialized and made globally accessible');
  });
  
  async function runCode() {
    const code = editor.getValue();
    const outputDiv = document.getElementById("outputContent");
    
    // Show loading state
    outputDiv.innerHTML = '<div style="color: #4fc3f7;">Running code...</div>';

    try {
      const res = await fetch("https://emkc.org/api/v2/piston/execute", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          language: "python3",
          version: "3.10.0",
          files: [{ content: code }]
        })
      });

      const data = await res.json();
      
      if (data.run) {
        let output = '';
        
        if (data.run.stdout) {
          output += `<div style="color: #ffffff;">${data.run.stdout}</div>`;
        }
        
        if (data.run.stderr) {
          output += `<div style="color: #ff6b6b;">Error: ${data.run.stderr}</div>`;
        }
        
        if (!data.run.stdout && !data.run.stderr) {
          output = '<div style="color: #4fc3f7;">Code executed successfully (no output)</div>';
        }
        
        outputDiv.innerHTML = output;
      } else {
        outputDiv.innerHTML = '<div style="color: #ff6b6b;">Error: Failed to execute code</div>';
      }
    } catch (error) {
      outputDiv.innerHTML = `<div style="color: #ff6b6b;">Error: ${error.message}</div>`;
    }
  }
</script>


    <div class="status-bar">
        <div>Session: {{ session.id }} | Status: {{ session.status|title }}</div>
        <div id="connectionStatus">Connecting...</div>
    </div>

    <script>
        // WebSocket connection
        const websocketUrl = '{{ websocket_url }}';
        let socket = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;

        function connectWebSocket() {
            console.log('Attempting to connect to WebSocket:', websocketUrl);
            try {
                socket = new WebSocket(websocketUrl);
                
                socket.onopen = function(event) {
                    console.log('WebSocket connected to:', websocketUrl);
                    document.getElementById('connectionStatus').textContent = 'Connected';
                    document.getElementById('connectionStatus').className = 'success';
                    reconnectAttempts = 0;
                };
                
                socket.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                };
                
                socket.onclose = function(event) {
                    console.log('WebSocket disconnected');
                    document.getElementById('connectionStatus').textContent = 'Disconnected';
                    document.getElementById('connectionStatus').className = 'error';
                    
                    // Attempt to reconnect
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        setTimeout(connectWebSocket, 2000 * reconnectAttempts);
                    }
                };
                
                socket.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    document.getElementById('connectionStatus').textContent = 'Error';
                    document.getElementById('connectionStatus').className = 'error';
                };
            } catch (error) {
                console.error('Failed to connect WebSocket:', error);
                document.getElementById('connectionStatus').textContent = 'Connection Failed';
                document.getElementById('connectionStatus').className = 'error';
            }
        }

        function handleWebSocketMessage(data) {
            console.log('Received WebSocket message:', data);
            switch (data.type) {
                case 'chat_message':
                    console.log('Adding message:', data.sender, data.message);
                    
                    // Check if this is a special problem update message
                    if (data.sender === 'ai' && data.message.startsWith('PROBLEM_UPDATE:')) {
                        // Extract problem ID and update the problem window
                        const problemId = data.message.split(':')[1];
                        console.log('Problem update requested for ID:', problemId);
                        updateProblemWindow();
                        return; // Don't add this message to chat
                    }
                    
                    addMessage(data.sender, data.message);
                    
                    // Check if this is a problem presentation message
                    if (data.sender === 'ai' && data.message.includes('**') && data.message.includes('**')) {
                        // Extract problem data from the message (this is a simple approach)
                        // In a real implementation, you'd send structured data
                        setTimeout(() => {
                            // Try to get the current problem from the session
                            fetch(`/ai-interview/api/session-data/{{ session.id }}/`)
                                .then(response => response.json())
                                .then(sessionData => {
                                    if (sessionData.session.problem) {
                                        updateProblemContent(sessionData.session.problem);
                                        // Generate function signature for initial problem
                                        setTimeout(() => {
                                            generateFunctionSignature(sessionData.session.problem);
                                        }, 100); // Small delay to ensure Monaco editor is ready
                                    }
                                })
                                .catch(error => console.error('Error fetching session data:', error));
                        }, 1000);
                    }
                    break;
                case 'code_submission':
                    // Handle code submission from other clients
                    break;
                case 'error':
                    addMessage('system', `Error: ${data.message}`);
                    break;
            }
        }

        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (message && socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'chat_message',
                    message: message
                }));
                input.value = '';
            }
        }

        function addMessage(sender, content) {
            console.log('addMessage called with:', sender, content);
            const messagesContainer = document.getElementById('chatMessages');
            if (!messagesContainer) {
                console.error('Messages container not found!');
                return;
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            const timestamp = new Date().toLocaleTimeString();
            
            // Render markdown for AI messages, plain text for user messages
            let renderedContent;
            if (sender === 'ai' && typeof marked !== 'undefined') {
                try {
                    renderedContent = marked.parse(content);
                    console.log('Markdown rendered successfully');
                } catch (error) {
                    console.error('Markdown parsing error:', error);
                    renderedContent = content.replace(/\n/g, '<br>');
                }
            } else {
                renderedContent = content.replace(/\n/g, '<br>');
            }
            
            messageDiv.innerHTML = `
                <div class="message-header">${sender.toUpperCase()} - ${timestamp}</div>
                <div>${renderedContent}</div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            console.log('Message added to container');
            
            // Auto-speak AI messages if speech is enabled
            if (sender === 'ai' && window.speechEnabled) {
                speakText(content);
            }
        }


        async function submitCode() {
            const code = editor.getValue();
            const outputDiv = document.getElementById("outputContent");
            
            // Show loading state
            outputDiv.innerHTML = '<div style="color: #4fc3f7;">Running test cases...</div>';
            
            try {
                // Get current problem test cases (we'll need to implement this)
                const testCases = await getTestCases();
                
                if (!testCases || testCases.length === 0) {
                    outputDiv.innerHTML = '<div style="color: #ff9800;">No test cases available for this problem</div>';
                    return;
                }
                
                let results = [];
                let passed = 0;
                let total = testCases.length;
                
                // Run each test case with a small delay to avoid rate limiting
                for (let i = 0; i < testCases.length; i++) {
                    const testCase = testCases[i];
                    
                    // Show progress
                    outputDiv.innerHTML = `<div style="color: #4fc3f7;">Running test case ${i + 1}/${total}...</div>`;
                    
                    const result = await runTestCase(code, testCase, i + 1);
                    results.push(result);
                    if (result.passed) passed++;
                    
                    // Small delay between requests to avoid overwhelming Piston API
                    if (i < testCases.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
                
                // Display results
                displayTestResults(results, passed, total);
                
                // Also send to AI for analysis
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        type: 'code_submission',
                        code: code,
                        language: 'python',
                        testResults: { passed, total, results }
                    }));
                }
                
            } catch (error) {
                outputDiv.innerHTML = `<div style="color: #ff6b6b;">Error running test cases: ${error.message}</div>`;
            }
        }

        async function getTestCases() {
            // Try to get test cases from the current problem
            try {
                const response = await fetch(`/ai-interview/get-test-cases/{{ session.id }}/`);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Received test cases:', data.test_cases);
                    return data.test_cases || [];
                } else {
                    console.error('Failed to fetch test cases:', response.statusText);
                }
            } catch (error) {
                console.log('Could not fetch test cases from server:', error);
            }
            
            // Fallback to empty array if no test cases found
            console.log('No test cases found, returning empty array');
            return [];
        }
        
        function extractFunctionArgs(input) {
            // Extract function arguments from test case input
            // This is a more robust implementation that handles various problem types
            
            // Handle multiple parameter cases
            if (input.includes('nums =') && input.includes('target =')) {
                return 'nums, target';
            } else if (input.includes('a =') && input.includes('b =')) {
                return 'a, b';
            } else if (input.includes('s =') && input.includes('t =')) {
                return 's, t';
            } else if (input.includes('p =') && input.includes('q =')) {
                return 'p, q';
            } else if (input.includes('left =') && input.includes('right =')) {
                return 'left, right';
            }
            
            // Handle single parameter cases
            else if (input.includes('columnNumber =')) {
                return 'columnNumber';
            } else if (input.includes('digits =')) {
                return 'digits';
            } else if (input.includes('strs =')) {
                return 'strs';
            } else if (input.includes('nums =')) {
                return 'nums';
            } else if (input.includes('root =')) {
                return 'root';
            } else if (input.includes('s =')) {
                return 's';
            } else if (input.includes('word =')) {
                return 'word';
            } else if (input.includes('string =')) {
                return 'string';
            } else if (input.includes('head =')) {
                return 'head';
            } else if (input.includes('node =')) {
                return 'node';
            } else if (input.includes('val =')) {
                return 'val';
            } else if (input.includes('n =')) {
                return 'n';
            } else if (input.includes('x =')) {
                return 'x';
            }
            
            // Handle direct values (numbers, strings, arrays)
            else if (/^\d+$/.test(input.trim())) {
                // If input is just a number, use it directly
                return input.trim();
            } else if (/^".*"$/.test(input.trim())) {
                // If input is a quoted string, use it directly
                return input.trim();
            } else if (/^\[.*\]$/.test(input.trim())) {
                // If input is an array, use it directly
                return input.trim();
            } else if (/^(true|false)$/i.test(input.trim())) {
                // If input is a boolean, use it directly
                return input.trim();
            }
            
            // Fallback: try to extract parameter names from the input
            else {
                // Look for common patterns like "param = value"
                const paramMatch = input.match(/(\w+)\s*=/);
                if (paramMatch) {
                    return paramMatch[1];
                }
                
                // If no pattern matches, return empty string
                return '';
            }
        }

        function parseTestInput(input) {
            // Smart parser that handles complex inputs without breaking arrays/objects
            // Convert null to None for Python
            let processedInput = input.replace(/null/g, 'None').replace(/true/g, 'True').replace(/false/g, 'False');
            
            // If input doesn't contain '=', it's a direct value
            if (!processedInput.includes('=')) {
                return processedInput;
            }
            
            // Parse assignments intelligently by finding '=' and extracting key-value pairs
            const assignments = [];
            let currentPos = 0;
            
            while (currentPos < processedInput.length) {
                // Find next '=' sign
                const equalPos = processedInput.indexOf('=', currentPos);
                if (equalPos === -1) break;
                
                // Extract variable name (everything before '=' trimmed)
                const varStart = processedInput.lastIndexOf(',', equalPos);
                const varName = processedInput.substring(varStart === -1 ? 0 : varStart + 1, equalPos).trim();
                
                // Extract value (everything after '=' until next variable or end)
                let valueStart = equalPos + 1;
                let valueEnd = processedInput.length;
                
                // Find where this value ends by looking for next variable pattern
                // Pattern: ", varname ="
                const nextVarMatch = processedInput.substring(valueStart).match(/,\s*\w+\s*=/);
                if (nextVarMatch) {
                    valueEnd = valueStart + nextVarMatch.index;
                }
                
                const value = processedInput.substring(valueStart, valueEnd).trim();
                
                // Add assignment
                if (varName && value) {
                    assignments.push(`${varName} = ${value}`);
                }
                
                currentPos = valueEnd;
            }
            
            return assignments.join('\n');
        }

        async function runTestCase(code, testCase, testNumber) {
            try {
                // Get the current problem from the problem window
                const problemTitle = document.querySelector('.problem-title')?.textContent || '';
                
                // Prepare the test code based on the problem type
                let testCode = code;
                
                // Check if code uses LeetCode Solution class format
                const hasSolutionClass = code.includes('class Solution') || code.includes('class solution');
                
                if (hasSolutionClass) {
                    // Handle LeetCode Solution class format - this is the most common case
                    const methodMatch = code.match(/def\s+(\w+)\s*\(/);
                    if (methodMatch) {
                        const methodName = methodMatch[1];
                        const args = extractFunctionArgs(testCase.input);
                        
                        // Use smart parser that handles arrays properly
                        const variableAssignments = parseTestInput(testCase.input);
                        
                        testCode += `\n\n# Test case ${testNumber}\n${variableAssignments}\ntry:\n    solution = Solution()\n    result = solution.${methodName}(${args})\n    print(result)\nexcept Exception as e:\n    print(f"Error: {e}")`;
                    } else {
                        const variableAssignments = parseTestInput(testCase.input);
                        testCode += `\n\n# Test case ${testNumber}\n${variableAssignments}\ntry:\n    solution = Solution()\n    print("No method found")\nexcept Exception as e:\n    print(f"Error: {e}")`;
                    }
                } else {
                    // Handle standalone function format
                    const functionMatch = code.match(/def\s+(\w+)\s*\(/);
                    if (functionMatch) {
                        const functionName = functionMatch[1];
                        const args = extractFunctionArgs(testCase.input);
                        
                        // Use smart parser that handles arrays properly
                        const variableAssignments = parseTestInput(testCase.input);
                        
                        testCode += `\n\n# Test case ${testNumber}\n${variableAssignments}\ntry:\n    result = ${functionName}(${args})\n    print(result)\nexcept Exception as e:\n    print(f"Error: {e}")`;
                    } else {
                        // Fallback: just print error
                        const variableAssignments = parseTestInput(testCase.input);
                        testCode += `\n\n# Test case ${testNumber}\n${variableAssignments}\nprint("No function found")`;
                    }
                }
                
                // Execute code with timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                try {
                    const res = await fetch("https://emkc.org/api/v2/piston/execute", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            language: "python3",
                            version: "3.10.0",
                            files: [{ content: testCode }]
                        }),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);

                    if (!res.ok) {
                        return {
                            testNumber,
                            input: testCase.input,
                            expected: testCase.expected,
                            actual: null,
                            passed: false,
                            error: `HTTP ${res.status}: ${res.statusText}`
                        };
                    }

                    const data = await res.json();
                    
                    if (data.run && data.run.stdout) {
                        const output = data.run.stdout.trim();
                        const expected = testCase.expected;
                    
                    // Output is now just the result value (no "Result:" prefix)
                    let actualResult = output;
                    let passed = false;
                    
                    // Check if output contains an error
                    if (output.startsWith("Error:")) {
                        return {
                            testNumber,
                            input: testCase.input,
                            expected,
                            actual: null,
                            passed: false,
                            error: output
                        };
                    }
                    
                    // Normalize values for comparison
                    if (actualResult) {
                        // Convert string representations to comparable values
                        const normalizedActual = actualResult.toString().toLowerCase().trim();
                        const normalizedExpected = expected.toString().toLowerCase().trim();
                        
                        // Direct comparison
                        passed = normalizedActual === normalizedExpected ||
                                actualResult == expected || // Loose equality for type conversion
                                actualResult === expected;
                    }
                    
                    return {
                        testNumber,
                        input: testCase.input,
                        expected,
                        actual: actualResult,
                        passed,
                        error: data.run.stderr || null
                    };
                } else if (data.run && data.run.stderr) {
                    return {
                        testNumber,
                        input: testCase.input,
                        expected: testCase.expected,
                        actual: null,
                        passed: false,
                        error: data.run.stderr
                    };
                } else {
                    return {
                        testNumber,
                        input: testCase.input,
                        expected: testCase.expected,
                        actual: null,
                        passed: false,
                        error: data.run?.stderr || data.compile?.stderr || "No output received - code may have crashed"
                    };
                }
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    
                    if (fetchError.name === 'AbortError') {
                        return {
                            testNumber,
                            input: testCase.input,
                            expected: testCase.expected,
                            actual: null,
                            passed: false,
                            error: "Execution timeout (10 seconds) - code may be stuck in infinite loop"
                        };
                    }
                    
                    return {
                        testNumber,
                        input: testCase.input,
                        expected: testCase.expected,
                        actual: null,
                        passed: false,
                        error: `Network error: ${fetchError.message}`
                    };
                }
            } catch (error) {
                return {
                    testNumber,
                    input: testCase.input,
                    expected: testCase.expected,
                    actual: null,
                    passed: false,
                    error: error.message
                };
            }
        }

        function displayTestResults(results, passed, total) {
            const outputDiv = document.getElementById("outputContent");
            let html = `<div style="margin-bottom: 15px;">
                <strong style="color: ${passed === total ? '#4caf50' : '#ff9800'};">Test Results: ${passed}/${total} passed</strong>
            </div>`;
            
            results.forEach(result => {
                const statusColor = result.passed ? '#4caf50' : '#f44336';
                const statusText = result.passed ? 'PASS' : 'FAIL';
                
                html += `<div style="margin-bottom: 10px; padding: 10px; background-color: #2d2d30; border-radius: 5px;">
                    <div style="color: ${statusColor}; font-weight: bold;">Test Case ${result.testNumber}: ${statusText}</div>
                    <div style="color: #cccccc; font-size: 12px; margin: 5px 0;">Input: ${result.input}</div>
                    <div style="color: #4caf50; font-size: 12px;">Expected: ${result.expected}</div>
                    <div style="color: ${result.passed ? '#4caf50' : '#f44336'}; font-size: 12px;">Actual: ${result.actual || 'No output'}</div>
                    ${result.error ? `<div style="color: #ff6b6b; font-size: 12px;">Error: ${result.error}</div>` : ''}
                </div>`;
            });
            
            outputDiv.innerHTML = html;
        }

        function requestHint() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'request_hint',
                    hint_level: 1
                }));
            }
        }

        function requestCodeHelp() {
            const code = editor.getValue();
            if (code.trim() && socket && socket.readyState === WebSocket.OPEN) {
                const message = `I need help with my current code:\n\n\`\`\`python\n${code}\n\`\`\``;
                socket.send(JSON.stringify({
                    type: 'chat_message',
                    message: message
                }));
            } else {
                addMessage('system', 'Please write some code first before requesting help.');
            }
        }

        async function endInterview() {
            if (confirm('Are you sure you want to end the interview? This action cannot be undone.')) {
                // Stop recording if it's active
                if (isInterviewRecording) {
                    try {
                        await stopVideoRecording();
                        await fetch(`/ai-interview/api/stop-recording/{{ session.id }}/`, {
                            method: 'POST',
                            headers: {
                                'X-CSRFToken': getCookie('csrftoken')
                            }
                        });
                    } catch (error) {
                        console.error('Error stopping recording:', error);
                    }
                }
                
                // Send end interview message to AI
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        type: 'end_interview'
                    }));
                }
                
                // Redirect immediately to results page for better UX
                // AI feedback will be generated in the background
                window.location.href = '/ai-interview/results/{{ session.id }}/';
                
                // Trigger feedback generation in background (non-blocking)
                fetch(`/ai-interview/complete/{{ session.id }}/`, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': getCookie('csrftoken'),
                        'Content-Type': 'application/json'
                    }
                }).catch(error => {
                    console.error('Error generating feedback:', error);
                });
            }
        }

        // Resizable functionality
        function makeResizable() {
            const container = document.querySelector('.container');
            const codeEditorContainer = document.querySelector('.code-editor-container');
            let isResizing = false;
            let resizeType = null;
            let startX, startY, startLeftPercentage, startTopPercentage, startCodePercentage;

            // Helper function to get current grid values
            function getCurrentGridValues() {
                const gridColumns = container.style.gridTemplateColumns || '1fr 4px 1fr';
                const gridRows = container.style.gridTemplateRows || '1fr 4px 1fr';
                const codeGridRows = codeEditorContainer.style.gridTemplateRows || '1fr 4px 200px';
                
                // Parse current percentages
                const leftPercentage = gridColumns.includes('fr') ? 50 : parseFloat(gridColumns.split(' ')[0]);
                const topPercentage = gridRows.includes('fr') ? 50 : parseFloat(gridRows.split(' ')[0]);
                const codePercentage = codeGridRows.includes('fr') ? 70 : parseFloat(codeGridRows.split(' ')[0]);
                
                return { leftPercentage, topPercentage, codePercentage };
            }

            // Horizontal resize (between left and right panels)
            function handleHorizontalMouseDown(e) {
                if (e.target.id === 'horizontalResizeHandle') {
                    isResizing = true;
                    resizeType = 'horizontal';
                    startX = e.clientX;
                    const values = getCurrentGridValues();
                    startLeftPercentage = values.leftPercentage;
                    document.addEventListener('mousemove', handleHorizontalMouseMove);
                    document.addEventListener('mouseup', handleHorizontalMouseUp);
                    e.preventDefault();
                }
            }

            function handleHorizontalMouseMove(e) {
                if (!isResizing || resizeType !== 'horizontal') return;
                
                const deltaX = e.clientX - startX;
                const containerWidth = container.offsetWidth;
                const deltaPercentage = (deltaX / containerWidth) * 100;
                const leftPercentage = Math.max(20, Math.min(80, startLeftPercentage + deltaPercentage));
                const rightPercentage = 100 - leftPercentage;
                
                container.style.gridTemplateColumns = `${leftPercentage}% 4px ${rightPercentage}%`;
            }

            function handleHorizontalMouseUp() {
                if (resizeType === 'horizontal') {
                    isResizing = false;
                    resizeType = null;
                    document.removeEventListener('mousemove', handleHorizontalMouseMove);
                    document.removeEventListener('mouseup', handleHorizontalMouseUp);
                }
            }

            // Vertical resize (between problem and chat)
            function handleVerticalMouseDown(e) {
                if (e.target.id === 'verticalResizeHandle') {
                    isResizing = true;
                    resizeType = 'vertical';
                    startY = e.clientY;
                    const values = getCurrentGridValues();
                    startTopPercentage = values.topPercentage;
                    document.addEventListener('mousemove', handleVerticalMouseMove);
                    document.addEventListener('mouseup', handleVerticalMouseUp);
                    e.preventDefault();
                }
            }

            function handleVerticalMouseMove(e) {
                if (!isResizing || resizeType !== 'vertical') return;
                
                const deltaY = e.clientY - startY;
                const containerHeight = container.offsetHeight;
                const deltaPercentage = (deltaY / containerHeight) * 100;
                const topPercentage = Math.max(20, Math.min(80, startTopPercentage + deltaPercentage));
                const bottomPercentage = 100 - topPercentage;
                
                container.style.gridTemplateRows = `${topPercentage}% 4px ${bottomPercentage}%`;
            }

            function handleVerticalMouseUp() {
                if (resizeType === 'vertical') {
                    isResizing = false;
                    resizeType = null;
                    document.removeEventListener('mousemove', handleVerticalMouseMove);
                    document.removeEventListener('mouseup', handleVerticalMouseUp);
                }
            }

            // Code editor resize (between code editor and output)
            function handleCodeMouseDown(e) {
                if (e.target.id === 'codeResizeHandle') {
                    isResizing = true;
                    resizeType = 'code';
                    startY = e.clientY;
                    const values = getCurrentGridValues();
                    startCodePercentage = values.codePercentage;
                    document.addEventListener('mousemove', handleCodeMouseMove);
                    document.addEventListener('mouseup', handleCodeMouseUp);
                    e.preventDefault();
                }
            }

            function handleCodeMouseMove(e) {
                if (!isResizing || resizeType !== 'code') return;
                
                const deltaY = e.clientY - startY;
                const containerHeight = codeEditorContainer.offsetHeight;
                const deltaPercentage = (deltaY / containerHeight) * 100;
                const codePercentage = Math.max(30, Math.min(90, startCodePercentage + deltaPercentage));
                const outputHeight = Math.max(100, containerHeight - (codePercentage / 100) * containerHeight);
                
                codeEditorContainer.style.gridTemplateRows = `${codePercentage}% 4px ${outputHeight}px`;
            }

            function handleCodeMouseUp() {
                if (resizeType === 'code') {
                    isResizing = false;
                    resizeType = null;
                    document.removeEventListener('mousemove', handleCodeMouseMove);
                    document.removeEventListener('mouseup', handleCodeMouseUp);
                }
            }

            // Add event listeners
            document.addEventListener('mousedown', handleHorizontalMouseDown);
            document.addEventListener('mousedown', handleVerticalMouseDown);
            document.addEventListener('mousedown', handleCodeMouseDown);
        }

        function updateProblemContent(problemData) {
            const problemSection = document.querySelector('.problem-section');
            if (problemData) {
                // Format constraints properly
                let constraintsHtml = '';
                if (problemData.constraints) {
                    const constraints = problemData.constraints.split('\n').filter(line => line.trim());
                    constraintsHtml = `
                        <div class="problem-constraints">
                            <strong>Constraints:</strong>
                            ${constraints.map(constraint => `<div>${constraint.trim()}</div>`).join('')}
                        </div>
                    `;
                }

                // Format examples properly
                let examplesHtml = '';
                if (problemData.examples && problemData.examples.length > 0) {
                    examplesHtml = `
                        <div class="problem-examples">
                            <strong>Examples:</strong>
                            ${problemData.examples.map((example, index) => `
                                <div class="example">
                                    <div class="example-label">Example ${index + 1}:</div>
                                    <div><strong>Input:</strong> <code>${example.input}</code></div>
                                    <div><strong>Output:</strong> <code>${example.output}</code></div>
                                    ${example.explanation ? `<div><strong>Explanation:</strong> ${example.explanation}</div>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                problemSection.innerHTML = `
                    <div class="problem-title">${problemData.title}</div>
                    <div class="problem-difficulty difficulty-${problemData.difficulty}">
                        ${problemData.difficulty.charAt(0).toUpperCase() + problemData.difficulty.slice(1)}
                    </div>
                    <div class="problem-description">${problemData.description.replace(/\n/g, '<br>')}</div>
                    ${constraintsHtml}
                    ${examplesHtml}
                `;
                // Re-add resize handle after content update
                makeResizable();
            }
        }
        
        async function generateFunctionSignature(problemData) {
            if (!problemData || !problemData.title) {
                console.log('No problem data or title available for function signature generation');
                return;
            }
            
            console.log('Generating function signature for problem:', problemData.title);
            
            try {
                // Fetch the dynamic function signature from the server
                const response = await fetch(`/ai-interview/get-function-signature/{{ session.id }}/`);
                if (response.ok) {
                    const data = await response.json();
                    const signature = data.function_signature;
                    
                    console.log('Received function signature:', signature);
                    
                    if (signature) {
                        // Function to set the signature with retry logic
                        const setSignature = (retryCount = 0) => {
                            if (window.monacoEditor && typeof window.monacoEditor.setValue === 'function') {
                                window.monacoEditor.setValue(signature);
                                console.log('Function signature set in Monaco editor');
                                return true;
                            } else if (window.monacoEditor && typeof window.monacoEditor.getModel === 'function') {
                                // Try alternative method
                                const model = window.monacoEditor.getModel();
                                if (model) {
                                    model.setValue(signature);
                                    console.log('Function signature set via model');
                                    return true;
                                }
                            }
                            
                            // If not successful and we haven't exceeded retries, try again
                            if (retryCount < 3) {
                                console.log(`Monaco editor not ready, retrying in ${(retryCount + 1) * 200}ms... (attempt ${retryCount + 1}/3)`);
                                setTimeout(() => setSignature(retryCount + 1), (retryCount + 1) * 200);
                            } else {
                                console.log('Monaco editor still not available after 3 retries');
                            }
                            return false;
                        };
                        
                        setSignature();
                    } else {
                        console.log('No function signature received from server');
                    }
                } else {
                    console.error('Failed to fetch function signature:', response.statusText);
                }
            } catch (error) {
                console.error('Error fetching function signature:', error);
            }
        }

        function updateProblemWindow() {
            // Fetch the latest session data to get the new problem
            fetch(`/ai-interview/api/session-data/{{ session.id }}/`)
                .then(response => response.json())
                .then(sessionData => {
                    if (sessionData.session.problem) {
                        console.log('Updating problem window with new problem:', sessionData.session.problem);
                        updateProblemContent(sessionData.session.problem);
                        
                        // Clear the code editor first
                        if (window.monacoEditor && typeof window.monacoEditor.setValue === 'function') {
                            window.monacoEditor.setValue('');
                        }
                        
                        // Generate and set function signature in IDE
                        generateFunctionSignature(sessionData.session.problem);
                        
                        // Clear the output
                        const outputDiv = document.getElementById('output');
                        if (outputDiv) {
                            outputDiv.innerHTML = '';
                        }
                        
                        // Show a brief notification
                        const problemSection = document.querySelector('.problem-section');
                        if (problemSection) {
                            const notification = document.createElement('div');
                            notification.className = 'problem-update-notification';
                            notification.textContent = 'Problem updated!';
                            notification.style.cssText = `
                                position: absolute;
                                top: 10px;
                                right: 10px;
                                background: #4CAF50;
                                color: white;
                                padding: 8px 16px;
                                border-radius: 4px;
                                font-size: 14px;
                                z-index: 1000;
                                animation: fadeInOut 2s ease-in-out;
                            `;
                            
                            // Add CSS animation
                            if (!document.getElementById('problem-update-animation')) {
                                const style = document.createElement('style');
                                style.id = 'problem-update-animation';
                                style.textContent = `
                                    @keyframes fadeInOut {
                                        0% { opacity: 0; transform: translateY(-10px); }
                                        20% { opacity: 1; transform: translateY(0); }
                                        80% { opacity: 1; transform: translateY(0); }
                                        100% { opacity: 0; transform: translateY(-10px); }
                                    }
                                `;
                                document.head.appendChild(style);
                            }
                            
                            problemSection.style.position = 'relative';
                            problemSection.appendChild(notification);
                            
                            // Remove notification after animation
                            setTimeout(() => {
                                if (notification.parentNode) {
                                    notification.parentNode.removeChild(notification);
                                }
                            }, 2000);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching updated session data:', error);
                });
        }

        // Event listeners
        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Initialize WebSocket connection
        connectWebSocket();
        
        // Initialize resizable layout
        makeResizable();

        // Voice functionality
        let recognition = null;
        let isRecording = false;
        let speechSynthesis = window.speechSynthesis;
        let currentUtterance = null;
        let continuousListening = false;
        let silenceTimeout = null;
        let speechStartTime = null;
        let lastSpeechTime = null;
        
        // Character tracking for ElevenLabs usage
        let totalCharactersUsed = 0;
        const MAX_FREE_CHARACTERS = 10000; // ElevenLabs free tier limit

        // Initialize speech recognition
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window) {
                recognition = new webkitSpeechRecognition();
            } else if ('SpeechRecognition' in window) {
                recognition = new SpeechRecognition();
            } else {
                document.getElementById('voiceStatus').textContent = 'Speech recognition not supported';
                return false;
            }

            recognition.continuous = true; // Enable continuous listening
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            recognition.onstart = function() {
                isRecording = true;
                document.getElementById('micButton').classList.add('recording');
                document.getElementById('voiceStatus').textContent = 'Listening...';
            };

            recognition.onresult = function(event) {
                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (finalTranscript) {
                    // Update the input field
                    document.getElementById('messageInput').value = finalTranscript;
                    document.getElementById('voiceStatus').textContent = 'Processing...';
                    
                    // In continuous mode, automatically send the message
                    if (continuousListening) {
                        setTimeout(() => {
                            sendMessage();
                            // Clear the input field after sending
                            document.getElementById('messageInput').value = '';
                            // Restart listening after sending
                            if (continuousListening) {
                                setTimeout(() => {
                                    startContinuousListening();
                                }, 1000);
                            }
                        }, 500);
                    }
                } else if (interimTranscript) {
                    document.getElementById('messageInput').value = interimTranscript;
                }
            };

            recognition.onerror = function(event) {
                console.error('Speech recognition error:', event.error);
                
                // Handle different error types
                if (event.error === 'not-allowed') {
                    document.getElementById('voiceStatus').textContent = 'Microphone access denied. Click the lock icon in your browser address bar and allow microphone access, then try again.';
                    document.getElementById('voiceStatus').style.color = '#f44336';
                    stopContinuousListening();
                    
                    // Show a more detailed help message
                    setTimeout(() => {
                        alert('Microphone Access Required\n\nTo use voice features:\n1. Click the lock icon 🔒 in your browser address bar\n2. Click "Site settings" or "Permissions"\n3. Set Microphone to "Allow"\n4. Refresh the page and try again');
                    }, 1000);
                } else if (event.error === 'no-speech') {
                    document.getElementById('voiceStatus').textContent = 'No speech detected. Try speaking again.';
                    document.getElementById('voiceStatus').style.color = '#ff9800';
                    // Restart listening for no-speech errors
                    if (continuousListening) {
                        setTimeout(() => {
                            startContinuousListening();
                        }, 1000);
                    }
                } else if (event.error === 'network') {
                    document.getElementById('voiceStatus').textContent = 'Network error. Retrying...';
                    document.getElementById('voiceStatus').style.color = '#ff9800';
                    // Restart listening for network errors
                    if (continuousListening) {
                        setTimeout(() => {
                            startContinuousListening();
                        }, 2000);
                    }
                } else {
                    document.getElementById('voiceStatus').textContent = 'Speech error: ' + event.error;
                    document.getElementById('voiceStatus').style.color = '#f44336';
                    // Restart listening for other errors
                    if (continuousListening) {
                        setTimeout(() => {
                            startContinuousListening();
                        }, 1000);
                    }
                }
                
                stopRecording();
            };

            recognition.onend = function() {
                stopRecording();
                
                // Restart continuous listening if it's enabled
                if (continuousListening) {
                    setTimeout(() => {
                        startContinuousListening();
                    }, 100);
                }
            };

            return true;
        }

        function toggleVoiceInput() {
            console.log('toggleVoiceInput called, current state:', continuousListening);
            
            // Visual feedback that button was clicked
            const button = document.getElementById('micButton');
            button.style.transform = 'scale(0.95)';
            setTimeout(() => {
                button.style.transform = 'scale(1)';
            }, 100);
            
            if (!recognition) {
                console.log('No recognition object, initializing...');
                if (!initSpeechRecognition()) {
                    console.log('Failed to initialize speech recognition');
                    return;
                }
            }

            if (continuousListening) {
                console.log('Stopping voice input');
                stopContinuousListening();
            } else {
                console.log('Starting voice input');
                startContinuousListening();
            }
        }

        function stopRecording() {
            isRecording = false;
            document.getElementById('micButton').classList.remove('recording');
            document.getElementById('voiceStatus').textContent = '';
            
            if (recognition) {
                recognition.stop();
            }
        }

        // Voice input functions

        function startContinuousListening() {
            console.log('startContinuousListening called');
            console.log('recognition object:', recognition);
            
            if (!recognition) {
                console.log('No recognition object, initializing...');
                if (!initSpeechRecognition()) {
                    console.log('Failed to initialize speech recognition');
                    return;
                }
            }

            console.log('Setting continuous listening to true');
            continuousListening = true;
            document.getElementById('micButton').classList.add('active');
            document.getElementById('micButton').textContent = '🎤';
            document.getElementById('voiceStatus').textContent = '🎤 Starting microphone...';
            document.getElementById('voiceStatus').style.color = '#4CAF50';
            
            // Request microphone permission and start listening
            if (!isRecording) {
                try {
                    console.log('Starting recognition...');
                    recognition.start();
                    console.log('Recognition started successfully');
                } catch (error) {
                    console.error('Error starting continuous listening:', error);
                    document.getElementById('voiceStatus').textContent = 'Microphone access required - please allow and try again';
                    document.getElementById('voiceStatus').style.color = '#f44336';
                    continuousListening = false;
                    document.getElementById('micButton').classList.remove('active');
                }
            } else {
                console.log('Already recording, skipping start');
            }
        }

        function stopContinuousListening() {
            continuousListening = false;
            document.getElementById('micButton').classList.remove('active');
            document.getElementById('micButton').textContent = '🎤';
            document.getElementById('voiceStatus').textContent = '';
            document.getElementById('voiceStatus').style.color = '';
            
            // Stop current recording
            if (isRecording) {
                stopRecording();
            }
        }

        async function speakText(text) {
            // Stop any current speech
            if (currentUtterance) {
                speechSynthesis.cancel();
            }

            try {
                document.getElementById('speakerButton').classList.add('speaking');
                document.getElementById('voiceStatus').textContent = 'Generating speech...';

                // Track character usage
                const characterCount = text.length;
                totalCharactersUsed += characterCount;
                updateCharacterCounter();

                // Use ElevenLabs for natural speech synthesis
                const response = await fetch('/ai-interview/api/synthesize-speech/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        text: text,
                        voice_id: '21m00Tcm4TlvDq8ikWAM'  // Natural-sounding voice
                    })
                });

                if (!response.ok) {
                    // ElevenLabs API error (quota exceeded, etc.) - use fallback
                    console.log('ElevenLabs API error, using browser speech synthesis');
                    fallbackSpeechSynthesis(text);
                    return;
                }

                const data = await response.json();

                if (data.success && data.audio) {
                    // Show cache hit indicator if audio was cached
                    if (data.cached) {
                        showCacheHit();
                    }
                    
                    // Create audio element and play the generated speech
                    const audio = new Audio(`data:audio/mp3;base64,${data.audio}`);
                    
                    audio.onplay = function() {
                        document.getElementById('voiceStatus').textContent = 'Speaking...';
                    };

                    audio.onended = function() {
                        document.getElementById('speakerButton').classList.remove('speaking');
                        document.getElementById('voiceStatus').textContent = '';
                        currentUtterance = null;
                    };

                    audio.onerror = function() {
                        document.getElementById('speakerButton').classList.remove('speaking');
                        document.getElementById('voiceStatus').textContent = 'Speech error';
                        currentUtterance = null;
                    };

                    currentUtterance = audio;
                    await audio.play();
                } else {
                    throw new Error(data.error || 'Failed to generate speech');
                }
            } catch (error) {
                console.error('Speech synthesis error:', error);
                document.getElementById('speakerButton').classList.remove('speaking');
                document.getElementById('voiceStatus').textContent = 'Speech error';
                currentUtterance = null;
                
                // Fallback to built-in speech synthesis
                fallbackSpeechSynthesis(text);
            }
        }

        function fallbackSpeechSynthesis(text) {
            // Fallback to built-in Web Speech API
            const cleanText = text
                .replace(/\*\*(.*?)\*\*/g, '$1')
                .replace(/\*(.*?)\*/g, '$1')
                .replace(/`(.*?)`/g, '$1')
                .replace(/#{1,6}\s*/g, '')
                .replace(/\[(.*?)\]\(.*?\)/g, '$1')
                .replace(/\n+/g, ' ')
                .trim();

            const utterance = new SpeechSynthesisUtterance(cleanText);
            utterance.rate = 0.9;
            utterance.pitch = 1;
            utterance.volume = 0.8;

            utterance.onstart = function() {
                document.getElementById('speakerButton').classList.add('speaking');
                document.getElementById('voiceStatus').textContent = 'Speaking...';
            };

            utterance.onend = function() {
                document.getElementById('speakerButton').classList.remove('speaking');
                document.getElementById('voiceStatus').textContent = '';
                currentUtterance = null;
            };

            utterance.onerror = function(event) {
                console.error('Fallback speech synthesis error:', event.error);
                document.getElementById('speakerButton').classList.remove('speaking');
                document.getElementById('voiceStatus').textContent = 'Speech error';
                currentUtterance = null;
            };

            currentUtterance = utterance;
            speechSynthesis.speak(utterance);
        }

        // Re-speak the last AI message (uses cached audio to save API calls)
        async function respeakLastAI() {
            try {
                // Disable button during request
                const respeakButton = document.getElementById('respeakButton');
                respeakButton.disabled = true;
                respeakButton.textContent = '⏳';
                
                // Get the last AI message from the session
                const response = await fetch(`/ai-interview/api/last-ai-message/{{ session.id }}/`);
                const data = await response.json();
                
                if (data.success && data.message) {
                    // Use the cached audio (this will use cache if available, or generate new if not)
                    await speakText(data.message);
                } else {
                    document.getElementById('voiceStatus').textContent = 'No AI message to re-speak';
                    setTimeout(() => {
                        document.getElementById('voiceStatus').textContent = '';
                    }, 2000);
                }
            } catch (error) {
                console.error('Error getting last AI message:', error);
                document.getElementById('voiceStatus').textContent = 'Error getting last message';
                setTimeout(() => {
                    document.getElementById('voiceStatus').textContent = '';
                }, 2000);
            } finally {
                // Re-enable button
                const respeakButton = document.getElementById('respeakButton');
                respeakButton.disabled = false;
                respeakButton.textContent = '🔁';
            }
        }

        function toggleSpeaking() {
            if (currentUtterance && speechSynthesis.speaking) {
                speechSynthesis.cancel();
                document.getElementById('speakerButton').classList.remove('speaking');
                document.getElementById('voiceStatus').textContent = '';
            } else {
                // Get the last AI message and speak it
                const messages = document.querySelectorAll('.message.ai');
                if (messages.length > 0) {
                    const lastMessage = messages[messages.length - 1];
                    const messageContent = lastMessage.querySelector('div:last-child').textContent;
                    speakText(messageContent);
                } else {
                    document.getElementById('voiceStatus').textContent = 'No AI message to speak';
                }
            }
        }

        // Helper function to get CSRF token
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        // Character counter functions
        function updateCharacterCounter() {
            const counter = document.getElementById('characterCounter');
            const percentage = (totalCharactersUsed / MAX_FREE_CHARACTERS) * 100;
            
            counter.textContent = `${totalCharactersUsed}/${MAX_FREE_CHARACTERS} chars`;
            
            // Update styling based on usage
            counter.className = 'character-counter';
            if (percentage >= 80) {
                counter.classList.add('critical');
            } else if (percentage >= 60) {
                counter.classList.add('warning');
            }
        }
        
        // Show cache hit indicator
        function showCacheHit() {
            const status = document.getElementById('voiceStatus');
            status.textContent = 'Using cached audio (saved API call!)';
            status.style.color = '#4CAF50';
            setTimeout(() => {
                status.textContent = '';
                status.style.color = '';
            }, 2000);
        }

        // Initialize voice functionality
        window.speechEnabled = true;
        
        // Initialize speech recognition on page load
        if (initSpeechRecognition()) {
            console.log('Speech recognition initialized successfully');
        } else {
            console.log('Speech recognition not available');
        }
        
        updateCharacterCounter();
        
        // Don't start voice input automatically - requires user interaction
        // User needs to click the mic button to enable microphone access
        
        // Interview recording functionality
        let isInterviewRecording = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStream = null;
        
        async function toggleRecording() {
            const button = document.getElementById('recordingButton');
            
            if (isInterviewRecording) {
                // Stop recording
                await stopVideoRecording();
                
                try {
                    const response = await fetch(`/ai-interview/api/stop-recording/{{ session.id }}/`, {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': getCookie('csrftoken')
                        }
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        isInterviewRecording = false;
                        button.textContent = '🎥 Start Recording';
                        button.classList.remove('recording');
                        console.log('Recording stopped. Duration:', data.duration_seconds, 'seconds');
                    } else {
                        console.error('Failed to stop recording:', data.error);
                    }
                } catch (error) {
                    console.error('Error stopping recording:', error);
                }
            } else {
                // Start recording
                const started = await startVideoRecording();
                if (started) {
                    try {
                        const response = await fetch(`/ai-interview/api/start-recording/{{ session.id }}/`, {
                            method: 'POST',
                            headers: {
                                'X-CSRFToken': getCookie('csrftoken')
                            }
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            isInterviewRecording = true;
                            button.textContent = '⏹️ Stop Recording';
                            button.classList.add('recording');
                            console.log('Recording started. ID:', data.recording_id);
                        } else {
                            console.error('Failed to start recording:', data.error);
                        }
                    } catch (error) {
                        console.error('Error starting recording:', error);
                    }
                }
            }
        }
        
        // Video recording functions
        async function startVideoRecording() {
            try {
                // Request screen capture with audio
                recordingStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        mediaSource: 'screen',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        frameRate: { ideal: 30 }
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    }
                });
                
                // Set up MediaRecorder
                const options = {
                    mimeType: 'video/webm;codecs=vp9,opus',
                    videoBitsPerSecond: 2500000, // 2.5 Mbps
                    audioBitsPerSecond: 128000   // 128 kbps
                };
                
                // Fallback to different codec if vp9 not supported
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm;codecs=vp8,opus';
                }
                
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm';
                }
                
                mediaRecorder = new MediaRecorder(recordingStream, options);
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = function() {
                    console.log('MediaRecorder stopped, chunks:', recordedChunks.length);
                };
                
                mediaRecorder.onerror = function(event) {
                    console.error('MediaRecorder error:', event.error);
                };
                
                // Start recording
                mediaRecorder.start(1000); // Collect data every second
                console.log('Video recording started');
                
                // Handle stream end (user stops sharing screen)
                recordingStream.getVideoTracks()[0].onended = function() {
                    console.log('Screen sharing ended by user');
                    if (isInterviewRecording) {
                        toggleRecording(); // Stop recording
                    }
                };
                
                return true;
                
            } catch (error) {
                console.error('Error starting video recording:', error);
                alert('Failed to start screen recording. Please ensure you grant permission to share your screen.');
                return false;
            }
        }
        
        async function stopVideoRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                console.log('Video recording stopped');
            }
            
            if (recordingStream) {
                recordingStream.getTracks().forEach(track => track.stop());
                recordingStream = null;
            }
            
            // Store the recorded video for later upload
            if (recordedChunks.length > 0) {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                window.recordedVideoBlob = blob;
                console.log('Video blob created, size:', blob.size, 'bytes');
                
                // Upload the video to the server
                await uploadVideoToServer(blob);
            }
        }
        
        async function uploadVideoToServer(videoBlob) {
            try {
                const formData = new FormData();
                formData.append('video', videoBlob, `interview_${Date.now()}.webm`);
                formData.append('session_id', '{{ session.id }}');
                
                const response = await fetch('/ai-interview/api/upload-video/', {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log('Video uploaded successfully:', data.video_url);
                } else {
                    console.error('Failed to upload video:', data.error);
                }
                
            } catch (error) {
                console.error('Error uploading video:', error);
            }
        }
    </script>
</body>
</html>

