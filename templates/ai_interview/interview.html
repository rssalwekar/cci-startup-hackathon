<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Coding Interview - Session {{ session.id }}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 4px 1fr;
            grid-template-rows: 1fr 4px 1fr;
            height: 100vh;
            background-color: #1e1e1e;
        }

        .problem-section {
            grid-column: 1;
            grid-row: 1;
            background-color: #2d2d30;
            padding: 20px;
            overflow-y: auto;
            border: 1px solid #3e3e42;
        }

        .chat-section {
            grid-column: 1;
            grid-row: 3;
            background-color: #252526;
            display: flex;
            flex-direction: column;
            border: 1px solid #3e3e42;
            min-height: 0;
        }

        .ide-section {
            grid-column: 3;
            grid-row: 1 / 4;
            background-color: #1e1e1e;
            display: flex;
            flex-direction: column;
            border: 1px solid #3e3e42;
        }

        .resize-handle-horizontal {
            grid-column: 2;
            grid-row: 1 / 4;
            background-color: #3e3e42;
            cursor: col-resize;
            position: relative;
        }

        .resize-handle-horizontal:hover {
            background-color: #4fc3f7;
        }

        .resize-handle-vertical {
            grid-column: 1;
            grid-row: 2;
            background-color: #3e3e42;
            cursor: row-resize;
            position: relative;
        }

        .resize-handle-vertical:hover {
            background-color: #4fc3f7;
        }

        .resize-handle {
            background-color: #3e3e42;
            cursor: col-resize;
            width: 4px;
            position: relative;
        }

        .resize-handle:hover {
            background-color: #4fc3f7;
        }

        .resize-handle-vertical {
            background-color: #3e3e42;
            cursor: row-resize;
            height: 4px;
            position: relative;
        }

        .resize-handle-vertical:hover {
            background-color: #4fc3f7;
        }

        .problem-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #4fc3f7;
            line-height: 1.2;
        }

        .problem-difficulty {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .difficulty-easy { background-color: #4caf50; color: white; }
        .difficulty-medium { background-color: #ff9800; color: white; }
        .difficulty-hard { background-color: #f44336; color: white; }

        .problem-description {
            line-height: 1.6;
            margin-bottom: 20px;
            font-size: 16px;
            color: #ffffff;
        }

        .problem-constraints {
            background-color: #2d2d30;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #3e3e42;
        }

        .problem-constraints strong {
            color: #ffffff;
            font-size: 16px;
            display: block;
            margin-bottom: 8px;
        }

        .problem-constraints div {
            color: #cccccc;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }

        .problem-examples {
            margin-bottom: 20px;
        }

        .problem-examples strong {
            color: #ffffff;
            font-size: 16px;
            display: block;
            margin-bottom: 12px;
        }

        .example {
            margin-bottom: 16px;
            padding: 12px;
            background-color: #2d2d30;
            border-radius: 6px;
            border: 1px solid #3e3e42;
        }

        .example-label {
            font-weight: bold;
            color: #4fc3f7;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .example div {
            margin-bottom: 6px;
            font-size: 14px;
            line-height: 1.4;
        }

        .example strong {
            color: #ffffff;
            font-weight: 600;
        }

        .example code {
            background-color: #1e1e1e;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #4fc3f7;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            min-height: 0;
        }

        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
            max-width: 80%;
        }

        .message.user {
            background-color: #007acc;
            margin-left: auto;
        }

        .message.ai {
            background-color: #3e3e42;
        }

        .message.system {
            background-color: #4caf50;
            text-align: center;
            max-width: 100%;
        }

        .message-header {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        /* Markdown styling for chat messages */
        .message h1, .message h2, .message h3, .message h4, .message h5, .message h6 {
            color: #4fc3f7;
            margin: 10px 0 5px 0;
        }

        .message code {
            background-color: #2d2d30;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #4fc3f7;
        }

        .message pre {
            background-color: #2d2d30;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 10px 0;
        }

        .message pre code {
            background: none;
            padding: 0;
            color: #ffffff;
        }

        .message ul, .message ol {
            margin: 10px 0;
            padding-left: 20px;
        }

        .message li {
            margin: 5px 0;
        }

        .message blockquote {
            border-left: 4px solid #4fc3f7;
            padding-left: 15px;
            margin: 10px 0;
            color: #cccccc;
        }

        .message strong {
            color: #ffffff;
            font-weight: bold;
        }

        .message em {
            color: #cccccc;
            font-style: italic;
        }

        .chat-input {
            padding: 20px;
            background-color: #2d2d30;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .chat-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            background-color: #3e3e42;
            color: white;
            font-size: 14px;
        }

        .chat-input input:focus {
            outline: none;
            border-color: #007acc;
        }

        .chat-input button {
            padding: 10px 20px;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .chat-input button:hover {
            background-color: #005a9e;
        }

        .voice-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .voice-button {
            padding: 10px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .voice-button.mic {
            background-color: #4caf50;
            color: white;
        }

        .voice-button.mic:hover {
            background-color: #45a049;
        }

        .voice-button.mic.recording {
            background-color: #f44336;
            animation: pulse 1s infinite;
        }

        .voice-button.speaker {
            background-color: #2196f3;
            color: white;
        }

        .voice-button.speaker:hover {
            background-color: #1976d2;
        }

        .voice-button.speaker.speaking {
            background-color: #ff9800;
            animation: pulse 1s infinite;
        }
        
        .voice-button.respeak {
            background-color: #FF9800;
            color: white;
        }
        
        .voice-button.respeak:hover {
            background-color: #F57C00;
        }
        
        .voice-button.respeak:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .voice-button.continuous {
            background-color: #9C27B0;
            color: white;
        }
        
        .voice-button.continuous:hover {
            background-color: #7B1FA2;
        }
        
        .voice-button.continuous.active {
            background-color: #4CAF50;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .voice-status {
            font-size: 12px;
            color: #cccccc;
            margin-left: 10px;
        }

        .character-counter {
            font-size: 10px;
            color: #888888;
            margin-left: 10px;
            padding: 2px 6px;
            background-color: #2d2d30;
            border-radius: 3px;
        }

        .character-counter.warning {
            color: #ff9800;
        }

        .character-counter.critical {
            color: #f44336;
        }

        .code-editor-container {
            flex: 1;
            display: grid;
            grid-template-rows: 1fr 4px 200px;
            min-height: 0;
        }

        .code-editor {
            grid-row: 1;
            background-color: #1e1e1e;
            border: none;
            color: #ffffff;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            padding: 20px;
            resize: none;
            outline: none;
        }

        .resize-handle-code {
            grid-row: 2;
            background-color: #3e3e42;
            cursor: row-resize;
            position: relative;
        }

        .resize-handle-code:hover {
            background-color: #4fc3f7;
        }

        .output-section {
            grid-row: 3;
            background-color: #2d2d30;
            padding: 20px;
            border-top: 1px solid #3e3e42;
            overflow-y: auto;
        }

        .ide-header {
            background-color: #2d2d30;
            padding: 10px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ide-title {
            font-weight: bold;
            color: #4fc3f7;
        }

        .ide-controls {
            display: flex;
            gap: 10px;
        }

        .ide-controls button {
            padding: 5px 10px;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .ide-controls button:hover {
            background-color: #005a9e;
        }

        .ide-controls button.end-interview {
            background-color: #dc3545;
        }

        .ide-controls button.end-interview:hover {
            background-color: #c82333;
        }


        .output-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #4fc3f7;
        }

        .output-content {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }

        .status-bar {
            background-color: #007acc;
            padding: 5px 20px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .loading {
            opacity: 0.6;
        }

        .error {
            color: #f44336;
        }

        .success {
            color: #4caf50;
        }

    </style>
</head>
<body>
    <div class="container">
        <!-- Problem Section (Top Left) -->
        <div class="problem-section">
            {% if session.problem %}
                <div class="problem-title">{{ session.problem.title }}</div>
                <div class="problem-difficulty difficulty-{{ session.problem.difficulty }}">
                    {{ session.problem.difficulty|title }}
                </div>
                <div class="problem-description">{{ session.problem.description|linebreaks }}</div>
                
                {% if session.problem.constraints %}
                    <div class="problem-constraints">
                        <strong>Constraints:</strong><br>
                        {{ session.problem.constraints|linebreaks }}
                    </div>
                {% endif %}
                
                {% if session.problem.examples %}
                    <div class="problem-examples">
                        <strong>Examples:</strong><br>
                        {% for example in session.problem.examples %}
                            <div class="example">
                                <div class="example-label">Example {{ forloop.counter }}:</div>
                                <div><strong>Input:</strong> {{ example.input }}</div>
                                <div><strong>Output:</strong> {{ example.output }}</div>
                                {% if example.explanation %}
                                    <div><strong>Explanation:</strong> {{ example.explanation }}</div>
                                {% endif %}
                            </div>
                        {% endfor %}
                    </div>
                {% endif %}
            {% else %}
                <div class="problem-title">Waiting for Problem Selection</div>
                <div class="problem-description">
                    The AI interviewer is assessing your preferences and will select an appropriate problem for you.
                </div>
            {% endif %}
        </div>

        <!-- Vertical Resize Handle (Between Problem and Chat) -->
        <div class="resize-handle-vertical" id="verticalResizeHandle"></div>

        <!-- Chat Section (Bottom Left) -->
        <div class="chat-section">
            <div class="chat-messages" id="chatMessages">
                {% for message in messages %}
                    <div class="message {{ message.message_type }}">
                        <div class="message-header">{{ message.message_type|title }} - {{ message.timestamp|date:"H:i" }}</div>
                        <div>{{ message.content|linebreaks }}</div>
                    </div>
                {% endfor %}
            </div>
            
            <div class="chat-input">
                <input type="text" id="messageInput" placeholder="Type your message..." autocomplete="off">
                <div class="voice-controls">
                    <button class="voice-button mic" id="micButton" onclick="toggleRecording()" title="Click to speak">
                        🎤
                    </button>
                    <button class="voice-button continuous" id="continuousButton" onclick="toggleContinuousListening()" title="Toggle Continuous Listening (Auto-detect speech)">
                        🎯
                    </button>
                    <button class="voice-button speaker" id="speakerButton" onclick="toggleSpeaking()" title="Click to hear AI response">
                        🔊
                    </button>
                    <button class="voice-button respeak" id="respeakButton" onclick="respeakLastAI()" title="Re-speak Last AI Message (Saves API calls)">
                        🔁
                    </button>
                    <span class="voice-status" id="voiceStatus"></span>
                    <span class="character-counter" id="characterCounter">0 chars</span>
                </div>
                <button onclick="sendMessage()">Send</button>
            </div>
        </div>

        <!-- Horizontal Resize Handle (Between Left and Right Panels) -->
        <div class="resize-handle-horizontal" id="horizontalResizeHandle"></div>

        <!-- IDE Section (Right Side) -->
        <div class="ide-section">
            <div class="ide-header">
                <div class="ide-title">Code Editor</div>
                <div class="ide-controls">
                    <button onclick="runCode()">Run</button>
                    <button onclick="submitCode()">Submit</button>
                    <button onclick="requestHint()">Hint</button>
                    <button onclick="requestCodeHelp()">Get Help</button>
                    <button onclick="endInterview()" class="end-interview">End Interview</button>
                </div>
            </div>
            
           <div class="code-editor-container">
  <!-- MONACO EDITOR -->
  <div id="monacoEditor" style="grid-row: 1; height: 100%; width: 100%;"></div>

  <!-- Code Editor Resize Handle -->
  <div class="resize-handle-code" id="codeResizeHandle"></div>

  <div class="output-section">
    <div class="output-title">Output</div>
    <div class="output-content" id="outputContent">Ready to run your code...</div>
  </div>
</div>


<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
  let editor;

  require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' } });
  require(["vs/editor/editor.main"], function () {
    editor = monaco.editor.create(document.getElementById('monacoEditor'), {
      value: '# Write your Python code here',
      language: 'python',
      theme: 'vs-dark',
      automaticLayout: true
    });
  });
  
  async function runCode() {
    const code = editor.getValue();
    const outputDiv = document.getElementById("outputContent");
    
    // Show loading state
    outputDiv.innerHTML = '<div style="color: #4fc3f7;">Running code...</div>';

    try {
      const res = await fetch("https://emkc.org/api/v2/piston/execute", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          language: "python3",
          version: "3.10.0",
          files: [{ content: code }]
        })
      });

      const data = await res.json();
      
      if (data.run) {
        let output = '';
        
        if (data.run.stdout) {
          output += `<div style="color: #ffffff;">${data.run.stdout}</div>`;
        }
        
        if (data.run.stderr) {
          output += `<div style="color: #ff6b6b;">Error: ${data.run.stderr}</div>`;
        }
        
        if (!data.run.stdout && !data.run.stderr) {
          output = '<div style="color: #4fc3f7;">Code executed successfully (no output)</div>';
        }
        
        outputDiv.innerHTML = output;
      } else {
        outputDiv.innerHTML = '<div style="color: #ff6b6b;">Error: Failed to execute code</div>';
      }
    } catch (error) {
      outputDiv.innerHTML = `<div style="color: #ff6b6b;">Error: ${error.message}</div>`;
    }
  }
</script>


    <div class="status-bar">
        <div>Session: {{ session.id }} | Status: {{ session.status|title }}</div>
        <div id="connectionStatus">Connecting...</div>
    </div>

    <script>
        // WebSocket connection
        const websocketUrl = '{{ websocket_url }}';
        let socket = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;

        function connectWebSocket() {
            try {
                socket = new WebSocket(websocketUrl);
                
                socket.onopen = function(event) {
                    console.log('WebSocket connected');
                    document.getElementById('connectionStatus').textContent = 'Connected';
                    document.getElementById('connectionStatus').className = 'success';
                    reconnectAttempts = 0;
                };
                
                socket.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                };
                
                socket.onclose = function(event) {
                    console.log('WebSocket disconnected');
                    document.getElementById('connectionStatus').textContent = 'Disconnected';
                    document.getElementById('connectionStatus').className = 'error';
                    
                    // Attempt to reconnect
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        setTimeout(connectWebSocket, 2000 * reconnectAttempts);
                    }
                };
                
                socket.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    document.getElementById('connectionStatus').textContent = 'Error';
                    document.getElementById('connectionStatus').className = 'error';
                };
            } catch (error) {
                console.error('Failed to connect WebSocket:', error);
                document.getElementById('connectionStatus').textContent = 'Connection Failed';
                document.getElementById('connectionStatus').className = 'error';
            }
        }

        function handleWebSocketMessage(data) {
            console.log('Received WebSocket message:', data);
            switch (data.type) {
                case 'chat_message':
                    console.log('Adding message:', data.sender, data.message);
                    
                    // Check if this is a special problem update message
                    if (data.sender === 'ai' && data.message.startsWith('PROBLEM_UPDATE:')) {
                        // Extract problem ID and update the problem window
                        const problemId = data.message.split(':')[1];
                        console.log('Problem update requested for ID:', problemId);
                        updateProblemWindow();
                        return; // Don't add this message to chat
                    }
                    
                    addMessage(data.sender, data.message);
                    
                    // Check if this is a problem presentation message
                    if (data.sender === 'ai' && data.message.includes('**') && data.message.includes('**')) {
                        // Extract problem data from the message (this is a simple approach)
                        // In a real implementation, you'd send structured data
                        setTimeout(() => {
                            // Try to get the current problem from the session
                            fetch(`/ai-interview/api/session-data/{{ session.id }}/`)
                                .then(response => response.json())
                                .then(sessionData => {
                                    if (sessionData.session.problem) {
                                        updateProblemContent(sessionData.session.problem);
                                    }
                                })
                                .catch(error => console.error('Error fetching session data:', error));
                        }, 1000);
                    }
                    break;
                case 'code_submission':
                    // Handle code submission from other clients
                    break;
                case 'error':
                    addMessage('system', `Error: ${data.message}`);
                    break;
            }
        }

        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (message && socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'chat_message',
                    message: message
                }));
                input.value = '';
            }
        }

        function addMessage(sender, content) {
            console.log('addMessage called with:', sender, content);
            const messagesContainer = document.getElementById('chatMessages');
            if (!messagesContainer) {
                console.error('Messages container not found!');
                return;
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            const timestamp = new Date().toLocaleTimeString();
            
            // Render markdown for AI messages, plain text for user messages
            let renderedContent;
            if (sender === 'ai' && typeof marked !== 'undefined') {
                try {
                    renderedContent = marked.parse(content);
                    console.log('Markdown rendered successfully');
                } catch (error) {
                    console.error('Markdown parsing error:', error);
                    renderedContent = content.replace(/\n/g, '<br>');
                }
            } else {
                renderedContent = content.replace(/\n/g, '<br>');
            }
            
            messageDiv.innerHTML = `
                <div class="message-header">${sender.toUpperCase()} - ${timestamp}</div>
                <div>${renderedContent}</div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            console.log('Message added to container');
            
            // Auto-speak AI messages if speech is enabled
            if (sender === 'ai' && window.speechEnabled) {
                speakText(content);
            }
        }


        async function submitCode() {
            const code = editor.getValue();
            const outputDiv = document.getElementById("outputContent");
            
            // Show loading state
            outputDiv.innerHTML = '<div style="color: #4fc3f7;">Running test cases...</div>';
            
            try {
                // Get current problem test cases (we'll need to implement this)
                const testCases = await getTestCases();
                
                if (!testCases || testCases.length === 0) {
                    outputDiv.innerHTML = '<div style="color: #ff9800;">No test cases available for this problem</div>';
                    return;
                }
                
                let results = [];
                let passed = 0;
                let total = testCases.length;
                
                // Run each test case
                for (let i = 0; i < testCases.length; i++) {
                    const testCase = testCases[i];
                    const result = await runTestCase(code, testCase, i + 1);
                    results.push(result);
                    if (result.passed) passed++;
                }
                
                // Display results
                displayTestResults(results, passed, total);
                
                // Also send to AI for analysis
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        type: 'code_submission',
                        code: code,
                        language: 'python',
                        testResults: { passed, total, results }
                    }));
                }
                
            } catch (error) {
                outputDiv.innerHTML = `<div style="color: #ff6b6b;">Error running test cases: ${error.message}</div>`;
            }
        }

        async function getTestCases() {
            // Try to get test cases from the current problem
            try {
                const response = await fetch(`/ai-interview/get-test-cases/{{ session.id }}/`);
                if (response.ok) {
                    const data = await response.json();
                    return data.test_cases || [];
                }
            } catch (error) {
                console.log('Could not fetch test cases from server:', error);
            }
            
            // Fallback to sample test cases for Two Sum problem
            return [
                { input: "nums = [2,7,11,15]\ntarget = 9", expected: "[0,1]" },
                { input: "nums = [3,2,4]\ntarget = 6", expected: "[1,2]" },
                { input: "nums = [3,3]\ntarget = 6", expected: "[0,1]" }
            ];
        }

        async function runTestCase(code, testCase, testNumber) {
            try {
                // Prepare the test code
                const testCode = `${code}\n\n# Test case ${testNumber}\n${testCase.input}\nprint("Expected:", ${testCase.expected})`;
                
                const res = await fetch("https://emkc.org/api/v2/piston/execute", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        language: "python3",
                        version: "3.10.0",
                        files: [{ content: testCode }]
                    })
                });

                const data = await res.json();
                
                if (data.run && data.run.stdout) {
                    const output = data.run.stdout.trim();
                    const expected = testCase.expected;
                    
                    // Simple comparison - in a real implementation, you'd parse the output properly
                    const passed = output.includes(expected) || output === expected;
                    
                    return {
                        testNumber,
                        input: testCase.input,
                        expected,
                        actual: output,
                        passed,
                        error: data.run.stderr || null
                    };
                } else {
                    return {
                        testNumber,
                        input: testCase.input,
                        expected: testCase.expected,
                        actual: null,
                        passed: false,
                        error: data.run?.stderr || "No output received"
                    };
                }
            } catch (error) {
                return {
                    testNumber,
                    input: testCase.input,
                    expected: testCase.expected,
                    actual: null,
                    passed: false,
                    error: error.message
                };
            }
        }

        function displayTestResults(results, passed, total) {
            const outputDiv = document.getElementById("outputContent");
            let html = `<div style="margin-bottom: 15px;">
                <strong style="color: ${passed === total ? '#4caf50' : '#ff9800'};">Test Results: ${passed}/${total} passed</strong>
            </div>`;
            
            results.forEach(result => {
                const statusColor = result.passed ? '#4caf50' : '#f44336';
                const statusText = result.passed ? 'PASS' : 'FAIL';
                
                html += `<div style="margin-bottom: 10px; padding: 10px; background-color: #2d2d30; border-radius: 5px;">
                    <div style="color: ${statusColor}; font-weight: bold;">Test Case ${result.testNumber}: ${statusText}</div>
                    <div style="color: #cccccc; font-size: 12px; margin: 5px 0;">Input: ${result.input}</div>
                    <div style="color: #4caf50; font-size: 12px;">Expected: ${result.expected}</div>
                    <div style="color: ${result.passed ? '#4caf50' : '#f44336'}; font-size: 12px;">Actual: ${result.actual || 'No output'}</div>
                    ${result.error ? `<div style="color: #ff6b6b; font-size: 12px;">Error: ${result.error}</div>` : ''}
                </div>`;
            });
            
            outputDiv.innerHTML = html;
        }

        function requestHint() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'request_hint',
                    hint_level: 1
                }));
            }
        }

        function requestCodeHelp() {
            const code = editor.getValue();
            if (code.trim() && socket && socket.readyState === WebSocket.OPEN) {
                const message = `I need help with my current code:\n\n\`\`\`python\n${code}\n\`\`\``;
                socket.send(JSON.stringify({
                    type: 'chat_message',
                    message: message
                }));
            } else {
                addMessage('system', 'Please write some code first before requesting help.');
            }
        }

        function endInterview() {
            if (confirm('Are you sure you want to end the interview? This action cannot be undone.')) {
                // Send end interview message to AI
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        type: 'end_interview'
                    }));
                }
                
                // Redirect to profile page to see the completed interview
                window.location.href = '/profile/';
            }
        }

        // Resizable functionality
        function makeResizable() {
            const container = document.querySelector('.container');
            const codeEditorContainer = document.querySelector('.code-editor-container');
            let isResizing = false;
            let resizeType = null;
            let startX, startY, startLeftPercentage, startTopPercentage, startCodePercentage;

            // Helper function to get current grid values
            function getCurrentGridValues() {
                const gridColumns = container.style.gridTemplateColumns || '1fr 4px 1fr';
                const gridRows = container.style.gridTemplateRows || '1fr 4px 1fr';
                const codeGridRows = codeEditorContainer.style.gridTemplateRows || '1fr 4px 200px';
                
                // Parse current percentages
                const leftPercentage = gridColumns.includes('fr') ? 50 : parseFloat(gridColumns.split(' ')[0]);
                const topPercentage = gridRows.includes('fr') ? 50 : parseFloat(gridRows.split(' ')[0]);
                const codePercentage = codeGridRows.includes('fr') ? 70 : parseFloat(codeGridRows.split(' ')[0]);
                
                return { leftPercentage, topPercentage, codePercentage };
            }

            // Horizontal resize (between left and right panels)
            function handleHorizontalMouseDown(e) {
                if (e.target.id === 'horizontalResizeHandle') {
                    isResizing = true;
                    resizeType = 'horizontal';
                    startX = e.clientX;
                    const values = getCurrentGridValues();
                    startLeftPercentage = values.leftPercentage;
                    document.addEventListener('mousemove', handleHorizontalMouseMove);
                    document.addEventListener('mouseup', handleHorizontalMouseUp);
                    e.preventDefault();
                }
            }

            function handleHorizontalMouseMove(e) {
                if (!isResizing || resizeType !== 'horizontal') return;
                
                const deltaX = e.clientX - startX;
                const containerWidth = container.offsetWidth;
                const deltaPercentage = (deltaX / containerWidth) * 100;
                const leftPercentage = Math.max(20, Math.min(80, startLeftPercentage + deltaPercentage));
                const rightPercentage = 100 - leftPercentage;
                
                container.style.gridTemplateColumns = `${leftPercentage}% 4px ${rightPercentage}%`;
            }

            function handleHorizontalMouseUp() {
                if (resizeType === 'horizontal') {
                    isResizing = false;
                    resizeType = null;
                    document.removeEventListener('mousemove', handleHorizontalMouseMove);
                    document.removeEventListener('mouseup', handleHorizontalMouseUp);
                }
            }

            // Vertical resize (between problem and chat)
            function handleVerticalMouseDown(e) {
                if (e.target.id === 'verticalResizeHandle') {
                    isResizing = true;
                    resizeType = 'vertical';
                    startY = e.clientY;
                    const values = getCurrentGridValues();
                    startTopPercentage = values.topPercentage;
                    document.addEventListener('mousemove', handleVerticalMouseMove);
                    document.addEventListener('mouseup', handleVerticalMouseUp);
                    e.preventDefault();
                }
            }

            function handleVerticalMouseMove(e) {
                if (!isResizing || resizeType !== 'vertical') return;
                
                const deltaY = e.clientY - startY;
                const containerHeight = container.offsetHeight;
                const deltaPercentage = (deltaY / containerHeight) * 100;
                const topPercentage = Math.max(20, Math.min(80, startTopPercentage + deltaPercentage));
                const bottomPercentage = 100 - topPercentage;
                
                container.style.gridTemplateRows = `${topPercentage}% 4px ${bottomPercentage}%`;
            }

            function handleVerticalMouseUp() {
                if (resizeType === 'vertical') {
                    isResizing = false;
                    resizeType = null;
                    document.removeEventListener('mousemove', handleVerticalMouseMove);
                    document.removeEventListener('mouseup', handleVerticalMouseUp);
                }
            }

            // Code editor resize (between code editor and output)
            function handleCodeMouseDown(e) {
                if (e.target.id === 'codeResizeHandle') {
                    isResizing = true;
                    resizeType = 'code';
                    startY = e.clientY;
                    const values = getCurrentGridValues();
                    startCodePercentage = values.codePercentage;
                    document.addEventListener('mousemove', handleCodeMouseMove);
                    document.addEventListener('mouseup', handleCodeMouseUp);
                    e.preventDefault();
                }
            }

            function handleCodeMouseMove(e) {
                if (!isResizing || resizeType !== 'code') return;
                
                const deltaY = e.clientY - startY;
                const containerHeight = codeEditorContainer.offsetHeight;
                const deltaPercentage = (deltaY / containerHeight) * 100;
                const codePercentage = Math.max(30, Math.min(90, startCodePercentage + deltaPercentage));
                const outputHeight = Math.max(100, containerHeight - (codePercentage / 100) * containerHeight);
                
                codeEditorContainer.style.gridTemplateRows = `${codePercentage}% 4px ${outputHeight}px`;
            }

            function handleCodeMouseUp() {
                if (resizeType === 'code') {
                    isResizing = false;
                    resizeType = null;
                    document.removeEventListener('mousemove', handleCodeMouseMove);
                    document.removeEventListener('mouseup', handleCodeMouseUp);
                }
            }

            // Add event listeners
            document.addEventListener('mousedown', handleHorizontalMouseDown);
            document.addEventListener('mousedown', handleVerticalMouseDown);
            document.addEventListener('mousedown', handleCodeMouseDown);
        }

        function updateProblemContent(problemData) {
            const problemSection = document.querySelector('.problem-section');
            if (problemData) {
                // Format constraints properly
                let constraintsHtml = '';
                if (problemData.constraints) {
                    const constraints = problemData.constraints.split('\n').filter(line => line.trim());
                    constraintsHtml = `
                        <div class="problem-constraints">
                            <strong>Constraints:</strong>
                            ${constraints.map(constraint => `<div>${constraint.trim()}</div>`).join('')}
                        </div>
                    `;
                }

                // Format examples properly
                let examplesHtml = '';
                if (problemData.examples && problemData.examples.length > 0) {
                    examplesHtml = `
                        <div class="problem-examples">
                            <strong>Examples:</strong>
                            ${problemData.examples.map((example, index) => `
                                <div class="example">
                                    <div class="example-label">Example ${index + 1}:</div>
                                    <div><strong>Input:</strong> <code>${example.input}</code></div>
                                    <div><strong>Output:</strong> <code>${example.output}</code></div>
                                    ${example.explanation ? `<div><strong>Explanation:</strong> ${example.explanation}</div>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                problemSection.innerHTML = `
                    <div class="problem-title">${problemData.title}</div>
                    <div class="problem-difficulty difficulty-${problemData.difficulty}">
                        ${problemData.difficulty.charAt(0).toUpperCase() + problemData.difficulty.slice(1)}
                    </div>
                    <div class="problem-description">${problemData.description.replace(/\n/g, '<br>')}</div>
                    ${constraintsHtml}
                    ${examplesHtml}
                `;
                // Re-add resize handle after content update
                makeResizable();
            }
        }

        function updateProblemWindow() {
            // Fetch the latest session data to get the new problem
            fetch(`/ai-interview/api/session-data/{{ session.id }}/`)
                .then(response => response.json())
                .then(sessionData => {
                    if (sessionData.session.problem) {
                        console.log('Updating problem window with new problem:', sessionData.session.problem);
                        updateProblemContent(sessionData.session.problem);
                        
                        // Clear the code editor
                        if (window.monacoEditor) {
                            window.monacoEditor.setValue('');
                        }
                        
                        // Clear the output
                        const outputDiv = document.getElementById('output');
                        if (outputDiv) {
                            outputDiv.innerHTML = '';
                        }
                        
                        // Show a brief notification
                        const problemSection = document.querySelector('.problem-section');
                        if (problemSection) {
                            const notification = document.createElement('div');
                            notification.className = 'problem-update-notification';
                            notification.textContent = 'Problem updated!';
                            notification.style.cssText = `
                                position: absolute;
                                top: 10px;
                                right: 10px;
                                background: #4CAF50;
                                color: white;
                                padding: 8px 16px;
                                border-radius: 4px;
                                font-size: 14px;
                                z-index: 1000;
                                animation: fadeInOut 2s ease-in-out;
                            `;
                            
                            // Add CSS animation
                            if (!document.getElementById('problem-update-animation')) {
                                const style = document.createElement('style');
                                style.id = 'problem-update-animation';
                                style.textContent = `
                                    @keyframes fadeInOut {
                                        0% { opacity: 0; transform: translateY(-10px); }
                                        20% { opacity: 1; transform: translateY(0); }
                                        80% { opacity: 1; transform: translateY(0); }
                                        100% { opacity: 0; transform: translateY(-10px); }
                                    }
                                `;
                                document.head.appendChild(style);
                            }
                            
                            problemSection.style.position = 'relative';
                            problemSection.appendChild(notification);
                            
                            // Remove notification after animation
                            setTimeout(() => {
                                if (notification.parentNode) {
                                    notification.parentNode.removeChild(notification);
                                }
                            }, 2000);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching updated session data:', error);
                });
        }

        // Event listeners
        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Initialize WebSocket connection
        connectWebSocket();
        
        // Initialize resizable layout
        makeResizable();

        // Voice functionality
        let recognition = null;
        let isRecording = false;
        let speechSynthesis = window.speechSynthesis;
        let currentUtterance = null;
        let continuousListening = false;
        let silenceTimeout = null;
        let speechStartTime = null;
        let lastSpeechTime = null;
        
        // Character tracking for ElevenLabs usage
        let totalCharactersUsed = 0;
        const MAX_FREE_CHARACTERS = 10000; // ElevenLabs free tier limit

        // Initialize speech recognition
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window) {
                recognition = new webkitSpeechRecognition();
            } else if ('SpeechRecognition' in window) {
                recognition = new SpeechRecognition();
            } else {
                document.getElementById('voiceStatus').textContent = 'Speech recognition not supported';
                return false;
            }

            recognition.continuous = true; // Enable continuous listening
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            recognition.onstart = function() {
                isRecording = true;
                document.getElementById('micButton').classList.add('recording');
                document.getElementById('voiceStatus').textContent = 'Listening...';
            };

            recognition.onresult = function(event) {
                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (finalTranscript) {
                    // Update the input field
                    document.getElementById('messageInput').value = finalTranscript;
                    document.getElementById('voiceStatus').textContent = 'Processing...';
                    
                    // In continuous mode, automatically send the message
                    if (continuousListening) {
                        setTimeout(() => {
                            sendMessage();
                            // Clear the input field after sending
                            document.getElementById('messageInput').value = '';
                            // Restart listening after sending
                            if (continuousListening) {
                                setTimeout(() => {
                                    startContinuousListening();
                                }, 1000);
                            }
                        }, 500);
                    }
                } else if (interimTranscript) {
                    document.getElementById('messageInput').value = interimTranscript;
                }
            };

            recognition.onerror = function(event) {
                console.error('Speech recognition error:', event.error);
                
                // Handle different error types
                if (event.error === 'not-allowed') {
                    document.getElementById('voiceStatus').textContent = 'Microphone access denied. Click the lock icon in your browser address bar and allow microphone access, then try again.';
                    document.getElementById('voiceStatus').style.color = '#f44336';
                    stopContinuousListening();
                    
                    // Show a more detailed help message
                    setTimeout(() => {
                        alert('Microphone Access Required\n\nTo use voice features:\n1. Click the lock icon 🔒 in your browser address bar\n2. Click "Site settings" or "Permissions"\n3. Set Microphone to "Allow"\n4. Refresh the page and try again');
                    }, 1000);
                } else if (event.error === 'no-speech') {
                    document.getElementById('voiceStatus').textContent = 'No speech detected. Try speaking again.';
                    document.getElementById('voiceStatus').style.color = '#ff9800';
                    // Restart listening for no-speech errors
                    if (continuousListening) {
                        setTimeout(() => {
                            startContinuousListening();
                        }, 1000);
                    }
                } else if (event.error === 'network') {
                    document.getElementById('voiceStatus').textContent = 'Network error. Retrying...';
                    document.getElementById('voiceStatus').style.color = '#ff9800';
                    // Restart listening for network errors
                    if (continuousListening) {
                        setTimeout(() => {
                            startContinuousListening();
                        }, 2000);
                    }
                } else {
                    document.getElementById('voiceStatus').textContent = 'Speech error: ' + event.error;
                    document.getElementById('voiceStatus').style.color = '#f44336';
                    // Restart listening for other errors
                    if (continuousListening) {
                        setTimeout(() => {
                            startContinuousListening();
                        }, 1000);
                    }
                }
                
                stopRecording();
            };

            recognition.onend = function() {
                stopRecording();
                
                // Restart continuous listening if it's enabled
                if (continuousListening) {
                    setTimeout(() => {
                        startContinuousListening();
                    }, 100);
                }
            };

            return true;
        }

        function toggleRecording() {
            if (!recognition) {
                if (!initSpeechRecognition()) {
                    return;
                }
            }

            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        function startRecording() {
            try {
                recognition.start();
            } catch (error) {
                console.error('Error starting speech recognition:', error);
                document.getElementById('voiceStatus').textContent = 'Error starting recording';
            }
        }

        function stopRecording() {
            isRecording = false;
            document.getElementById('micButton').classList.remove('recording');
            document.getElementById('voiceStatus').textContent = '';
            
            if (recognition) {
                recognition.stop();
            }
        }

        // Continuous listening functions
        function toggleContinuousListening() {
            console.log('toggleContinuousListening called, current state:', continuousListening);
            
            // Visual feedback that button was clicked
            const button = document.getElementById('continuousButton');
            button.style.transform = 'scale(0.95)';
            setTimeout(() => {
                button.style.transform = 'scale(1)';
            }, 100);
            
            if (continuousListening) {
                console.log('Stopping continuous listening');
                stopContinuousListening();
            } else {
                console.log('Starting continuous listening');
                startContinuousListening();
            }
        }

        function startContinuousListening() {
            console.log('startContinuousListening called');
            console.log('recognition object:', recognition);
            
            if (!recognition) {
                console.log('No recognition object, initializing...');
                if (!initSpeechRecognition()) {
                    console.log('Failed to initialize speech recognition');
                    return;
                }
            }

            console.log('Setting continuous listening to true');
            continuousListening = true;
            document.getElementById('continuousButton').classList.add('active');
            document.getElementById('continuousButton').textContent = '🎯';
            document.getElementById('voiceStatus').textContent = '🎤 Starting microphone...';
            document.getElementById('voiceStatus').style.color = '#4CAF50';
            
            // Request microphone permission and start listening
            if (!isRecording) {
                try {
                    console.log('Starting recognition...');
                    recognition.start();
                    console.log('Recognition started successfully');
                } catch (error) {
                    console.error('Error starting continuous listening:', error);
                    document.getElementById('voiceStatus').textContent = 'Microphone access required - please allow and try again';
                    document.getElementById('voiceStatus').style.color = '#f44336';
                    continuousListening = false;
                    document.getElementById('continuousButton').classList.remove('active');
                }
            } else {
                console.log('Already recording, skipping start');
            }
        }

        function stopContinuousListening() {
            continuousListening = false;
            document.getElementById('continuousButton').classList.remove('active');
            document.getElementById('continuousButton').textContent = '🎯';
            document.getElementById('voiceStatus').textContent = '';
            document.getElementById('voiceStatus').style.color = '';
            
            // Stop current recording
            if (isRecording) {
                stopRecording();
            }
        }

        async function speakText(text) {
            // Stop any current speech
            if (currentUtterance) {
                speechSynthesis.cancel();
            }

            try {
                document.getElementById('speakerButton').classList.add('speaking');
                document.getElementById('voiceStatus').textContent = 'Generating speech...';

                // Track character usage
                const characterCount = text.length;
                totalCharactersUsed += characterCount;
                updateCharacterCounter();

                // Use ElevenLabs for natural speech synthesis
                const response = await fetch('/ai-interview/api/synthesize-speech/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        text: text,
                        voice_id: '21m00Tcm4TlvDq8ikWAM'  // Natural-sounding voice
                    })
                });

                const data = await response.json();

                if (data.success && data.audio) {
                    // Show cache hit indicator if audio was cached
                    if (data.cached) {
                        showCacheHit();
                    }
                    
                    // Create audio element and play the generated speech
                    const audio = new Audio(`data:audio/mp3;base64,${data.audio}`);
                    
                    audio.onplay = function() {
                        document.getElementById('voiceStatus').textContent = 'Speaking...';
                    };

                    audio.onended = function() {
                        document.getElementById('speakerButton').classList.remove('speaking');
                        document.getElementById('voiceStatus').textContent = '';
                        currentUtterance = null;
                    };

                    audio.onerror = function() {
                        document.getElementById('speakerButton').classList.remove('speaking');
                        document.getElementById('voiceStatus').textContent = 'Speech error';
                        currentUtterance = null;
                    };

                    currentUtterance = audio;
                    await audio.play();
                } else {
                    throw new Error(data.error || 'Failed to generate speech');
                }
            } catch (error) {
                console.error('Speech synthesis error:', error);
                document.getElementById('speakerButton').classList.remove('speaking');
                document.getElementById('voiceStatus').textContent = 'Speech error';
                currentUtterance = null;
                
                // Fallback to built-in speech synthesis
                fallbackSpeechSynthesis(text);
            }
        }

        function fallbackSpeechSynthesis(text) {
            // Fallback to built-in Web Speech API
            const cleanText = text
                .replace(/\*\*(.*?)\*\*/g, '$1')
                .replace(/\*(.*?)\*/g, '$1')
                .replace(/`(.*?)`/g, '$1')
                .replace(/#{1,6}\s*/g, '')
                .replace(/\[(.*?)\]\(.*?\)/g, '$1')
                .replace(/\n+/g, ' ')
                .trim();

            const utterance = new SpeechSynthesisUtterance(cleanText);
            utterance.rate = 0.9;
            utterance.pitch = 1;
            utterance.volume = 0.8;

            utterance.onstart = function() {
                document.getElementById('speakerButton').classList.add('speaking');
                document.getElementById('voiceStatus').textContent = 'Speaking...';
            };

            utterance.onend = function() {
                document.getElementById('speakerButton').classList.remove('speaking');
                document.getElementById('voiceStatus').textContent = '';
                currentUtterance = null;
            };

            utterance.onerror = function(event) {
                console.error('Fallback speech synthesis error:', event.error);
                document.getElementById('speakerButton').classList.remove('speaking');
                document.getElementById('voiceStatus').textContent = 'Speech error';
                currentUtterance = null;
            };

            currentUtterance = utterance;
            speechSynthesis.speak(utterance);
        }

        // Re-speak the last AI message (uses cached audio to save API calls)
        async function respeakLastAI() {
            try {
                // Disable button during request
                const respeakButton = document.getElementById('respeakButton');
                respeakButton.disabled = true;
                respeakButton.textContent = '⏳';
                
                // Get the last AI message from the session
                const response = await fetch(`/ai-interview/api/last-ai-message/{{ session.id }}/`);
                const data = await response.json();
                
                if (data.success && data.message) {
                    // Use the cached audio (this will use cache if available, or generate new if not)
                    await speakText(data.message);
                } else {
                    document.getElementById('voiceStatus').textContent = 'No AI message to re-speak';
                    setTimeout(() => {
                        document.getElementById('voiceStatus').textContent = '';
                    }, 2000);
                }
            } catch (error) {
                console.error('Error getting last AI message:', error);
                document.getElementById('voiceStatus').textContent = 'Error getting last message';
                setTimeout(() => {
                    document.getElementById('voiceStatus').textContent = '';
                }, 2000);
            } finally {
                // Re-enable button
                const respeakButton = document.getElementById('respeakButton');
                respeakButton.disabled = false;
                respeakButton.textContent = '🔁';
            }
        }

        function toggleSpeaking() {
            if (currentUtterance && speechSynthesis.speaking) {
                speechSynthesis.cancel();
                document.getElementById('speakerButton').classList.remove('speaking');
                document.getElementById('voiceStatus').textContent = '';
            } else {
                // Get the last AI message and speak it
                const messages = document.querySelectorAll('.message.ai');
                if (messages.length > 0) {
                    const lastMessage = messages[messages.length - 1];
                    const messageContent = lastMessage.querySelector('div:last-child').textContent;
                    speakText(messageContent);
                } else {
                    document.getElementById('voiceStatus').textContent = 'No AI message to speak';
                }
            }
        }

        // Helper function to get CSRF token
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        // Character counter functions
        function updateCharacterCounter() {
            const counter = document.getElementById('characterCounter');
            const percentage = (totalCharactersUsed / MAX_FREE_CHARACTERS) * 100;
            
            counter.textContent = `${totalCharactersUsed}/${MAX_FREE_CHARACTERS} chars`;
            
            // Update styling based on usage
            counter.className = 'character-counter';
            if (percentage >= 80) {
                counter.classList.add('critical');
            } else if (percentage >= 60) {
                counter.classList.add('warning');
            }
        }
        
        // Show cache hit indicator
        function showCacheHit() {
            const status = document.getElementById('voiceStatus');
            status.textContent = 'Using cached audio (saved API call!)';
            status.style.color = '#4CAF50';
            setTimeout(() => {
                status.textContent = '';
                status.style.color = '';
            }, 2000);
        }

        // Initialize voice functionality
        window.speechEnabled = true;
        
        // Initialize speech recognition on page load
        if (initSpeechRecognition()) {
            console.log('Speech recognition initialized successfully');
        } else {
            console.log('Speech recognition not available');
        }
        
        updateCharacterCounter();
        
        // Don't start continuous listening automatically - requires user interaction
        // User needs to click the continuous button to enable microphone access
    </script>
</body>
</html>

